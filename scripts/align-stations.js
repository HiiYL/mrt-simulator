
import fs from 'fs';
import { nearestPointOnLine, point, distance } from '@turf/turf';
import { MRT_LINES } from '../src/data/mrt-routes.js';

const GEOJSON_PATH = 'src/data/singapore-mrt-fixed.json';
const OUTPUT_PATH = 'src/data/mrt-routes.js';

// Mapping line codes to GeoJSON feature codes (heuristic)
const LINE_MAP = {
    'NS': ['NS'],
    'EW': ['EW'],
    'CG': ['EW', 'CG'],
    'NE': ['NE'],
    'CC': ['CC'],
    'DT': ['DT'],
    'TE': ['TE'],
    'BP': ['BP'],
    'SK': ['SK', 'SE', 'SW'],
    'PG': ['PG', 'PE', 'PW']
};

console.log('Loading GeoJSON...');
const geojson = JSON.parse(fs.readFileSync(GEOJSON_PATH, 'utf8'));

console.log('Aligning stations...');
let updatedCount = 0;

Object.entries(MRT_LINES).forEach(([lineCode, line]) => {
    // Find candidate features for this line
    const targetCodes = LINE_MAP[lineCode] || [lineCode];

    // Find features that match the code logic
    const candidateFeatures = geojson.features.filter(f => {
        const fCode = f.properties.code;
        return targetCodes.includes(fCode);
    });

    if (candidateFeatures.length === 0) {
        console.warn(`No geometry features found for line ${lineCode}. Stations will not be aligned.`);
        return;
    }

    line.stations.forEach(station => {
        const pt = point([station.lng, station.lat]);

        let bestSnap = null;
        let minSnapDist = Infinity;

        // Try to snap to closest feature
        candidateFeatures.forEach(feature => {
            const snapped = nearestPointOnLine(feature, pt, { units: 'kilometers' });
            if (snapped.properties.dist < minSnapDist) {
                minSnapDist = snapped.properties.dist;
                bestSnap = snapped;
            }
        });

        // Threshold: 500m (0.5km). If further, assume data mismatch or underground/loop issue.
        if (bestSnap && minSnapDist < 0.5) {
            // Update coordinates
            const [newLng, newLat] = bestSnap.geometry.coordinates;

            // Only update if difference is significant to reduce noise (> 1 meter?)
            // 0.00001 deg ~ 1 meter.
            if (Math.abs(newLng - station.lng) > 0.00001 || Math.abs(newLat - station.lat) > 0.00001) {
                // console.log(`Aligned ${station.code} (${station.name}) by ${(minSnapDist * 1000).toFixed(1)}m`);
                station.lng = newLng;
                station.lat = newLat;
                updatedCount++;
            }
        } else {
            if (minSnapDist !== Infinity) {
                console.warn(`Station ${station.code} (${station.name}) is too far from track (${(minSnapDist * 1000).toFixed(0)}m). Skipping.`);
            }
        }
    });
});

console.log(`Aligned ${updatedCount} stations to track geometry.`);

// Generate Output File Content
const fileContent = `// Singapore MRT Network Data
// Contains all MRT lines, stations, and route coordinates
// Auto-generated by scripts/align-stations.js

export const MRT_LINES = ${JSON.stringify(MRT_LINES, null, 4)};

// Generate route polylines from station data
// Generate straight-line route for fallback
export function generateStraightLineGeoJSON(lineCode) {
    const line = MRT_LINES[lineCode];
    if (!line) return null;

    let coordinates;
    // If exact loop path is defined, use that for the visual line
    if (line.loopPath) {
        coordinates = line.loopPath.map(code => {
            const station = line.stations.find(s => s.code === code);
            return station ? [station.lng, station.lat] : null;
        }).filter(c => c !== null);
    } else {
        // Otherwise use sequential list of stations
        coordinates = line.stations.map(s => [s.lng, s.lat]);
    }

    return {
        type: 'Feature',
        properties: {
            code: lineCode, // Use 'code' to match new format
            line: lineCode,
            name: line.name,
            color: line.color,
            isFallback: true
        },
        geometry: {
            type: 'LineString',
            coordinates
        }
    };
}

// Generate station points GeoJSON
export function generateStationsGeoJSON() {
    const features = [];

    Object.entries(MRT_LINES).forEach(([lineCode, line]) => {
        line.stations.forEach(station => {
            features.push({
                type: 'Feature',
                properties: {
                    code: station.code,
                    name: station.name,
                    line: lineCode,
                    color: line.color
                },
                geometry: {
                    type: 'Point',
                    coordinates: [station.lng, station.lat]
                }
            });
        });
    });

    return {
        type: 'FeatureCollection',
        features
    };
}

// Get line info
export function getLineInfo(lineCode) {
    return MRT_LINES[lineCode] || null;
}

// Get all line codes
export function getAllLineCodes() {
    return Object.keys(MRT_LINES);
}
`;

fs.writeFileSync(OUTPUT_PATH, fileContent);
console.log(`Updated ${OUTPUT_PATH}`);
